-- Anonymous identity linking for anonymous -> authenticated continuity
-- Supports:
-- 1) Cookie-based linking (anon_id cookie)
-- 2) Email-hash fallback linking (cross-device / cleared-cookie scenarios)

CREATE TABLE IF NOT EXISTS public.anonymous_identities (
  anon_id text PRIMARY KEY,
  first_seen_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now(),
  first_path text,
  last_path text,
  user_agent text,
  analytics_consent text CHECK (analytics_consent IN ('granted', 'denied')),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.anonymous_identity_emails (
  anon_id text NOT NULL REFERENCES public.anonymous_identities(anon_id) ON DELETE CASCADE,
  email_hash text NOT NULL,
  first_seen_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (anon_id, email_hash)
);

CREATE INDEX IF NOT EXISTS idx_anonymous_identity_emails_email_hash
  ON public.anonymous_identity_emails(email_hash);

CREATE TABLE IF NOT EXISTS public.anonymous_identity_links (
  anon_id text NOT NULL REFERENCES public.anonymous_identities(anon_id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  link_method text NOT NULL CHECK (link_method IN ('cookie', 'email_hash', 'explicit')),
  linked_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (anon_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_anonymous_identity_links_user_id
  ON public.anonymous_identity_links(user_id);

CREATE TABLE IF NOT EXISTS public.anonymous_events (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anon_id text NOT NULL REFERENCES public.anonymous_identities(anon_id) ON DELETE CASCADE,
  user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  event_name text NOT NULL,
  event_properties jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_anonymous_events_anon_id
  ON public.anonymous_events(anon_id);

CREATE INDEX IF NOT EXISTS idx_anonymous_events_user_id
  ON public.anonymous_events(user_id);

CREATE INDEX IF NOT EXISTS idx_anonymous_events_created_at
  ON public.anonymous_events(created_at DESC);

DROP TRIGGER IF EXISTS set_anonymous_identities_updated_at ON public.anonymous_identities;
CREATE TRIGGER set_anonymous_identities_updated_at
  BEFORE UPDATE ON public.anonymous_identities
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_anonymous_identity_emails_updated_at ON public.anonymous_identity_emails;
CREATE TRIGGER set_anonymous_identity_emails_updated_at
  BEFORE UPDATE ON public.anonymous_identity_emails
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

ALTER TABLE public.anonymous_identities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.anonymous_identity_emails ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.anonymous_identity_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.anonymous_events ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.anonymous_identities FROM anon, authenticated;
REVOKE ALL ON TABLE public.anonymous_identity_emails FROM anon, authenticated;
REVOKE ALL ON TABLE public.anonymous_identity_links FROM anon, authenticated;
REVOKE ALL ON TABLE public.anonymous_events FROM anon, authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.anonymous_identities TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.anonymous_identity_emails TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.anonymous_identity_links TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.anonymous_events TO service_role;

GRANT USAGE, SELECT ON SEQUENCE public.anonymous_events_id_seq TO service_role;
