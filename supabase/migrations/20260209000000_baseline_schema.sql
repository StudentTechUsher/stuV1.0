

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE TYPE "public"."Program Types" AS ENUM (
    'major',
    'minor',
    'honors',
    'gen_ed',
    'graduate_no_gen_ed'
);


ALTER TYPE "public"."Program Types" OWNER TO "postgres";


COMMENT ON TYPE "public"."Program Types" IS 'Differentiates between program types like majors, minors, emphasis, etc.';



CREATE TYPE "public"."Roles" AS ENUM (
    'undergraduate',
    'graduate',
    'advisor',
    'admin',
    'superadmin'
);


ALTER TYPE "public"."Roles" OWNER TO "postgres";


COMMENT ON TYPE "public"."Roles" IS 'Describes the expected authorization for various profile types';



CREATE TYPE "public"."Year In School" AS ENUM (
    'Freshman',
    'Sophomore',
    'Junior',
    'Senior'
);


ALTER TYPE "public"."Year In School" OWNER TO "postgres";


COMMENT ON TYPE "public"."Year In School" IS 'Describes a student''s progress through school';



CREATE OR REPLACE FUNCTION "public"."grad_plan_broadcast_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  PERFORM realtime.broadcast_changes(
    'grad_plans:all',
    TG_OP,
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    NULL
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."grad_plan_broadcast_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."grad_plan_broadcast_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_student_uuid uuid;
BEGIN
  -- Fetch student uuid based on student_id in grad_plan
  SELECT uuid INTO v_student_uuid FROM public.student WHERE id = NEW.student_id;

  PERFORM realtime.send(
    'grad_plans:all',
    'new_grad_plan_ready',
    jsonb_build_object('grad_plan', to_jsonb(NEW), 'student_uuid', v_student_uuid),
    true -- private channel
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."grad_plan_broadcast_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  insert into public.profiles (id) values (new.id)
  on conflict (id) do nothing;
  return new;
end; $$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_advisor"() RETURNS boolean
    LANGUAGE "sql" STABLE
    AS $$
  select coalesce((auth.jwt()->>'role_id')::int = 2, false);
$$;


ALTER FUNCTION "public"."is_advisor"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notifications_broadcast_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  PERFORM realtime.broadcast_changes(
    'user:' || NEW.target_user_id::text || ':notifications', -- topic
    TG_OP, -- e.g., INSERT
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    NULL
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notifications_broadcast_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at = now();
  return new;
end; $$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."advisors" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "profile_id" "uuid",
    "programs" bigint[],
    "approved" boolean DEFAULT false NOT NULL
);


ALTER TABLE "public"."advisors" OWNER TO "postgres";


COMMENT ON TABLE "public"."advisors" IS 'A table to describe advisor permissions';



COMMENT ON COLUMN "public"."advisors"."programs" IS 'An array of program ID''s that an advisor has permission to interact with';



COMMENT ON COLUMN "public"."advisors"."approved" IS 'Stores if an advisor record is approved to perform advisor actions.';



ALTER TABLE "public"."advisors" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."advisors_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."ai_prompts" (
    "id" bigint NOT NULL,
    "prompt_name" "text",
    "prompt" "text",
    "ai_model" "text" DEFAULT 'gpt-5o-mini'::"text",
    "version" real DEFAULT '1'::real NOT NULL,
    "max_output_tokens" bigint DEFAULT '10000'::bigint NOT NULL,
    "university_id" bigint DEFAULT '1'::bigint NOT NULL,
    CONSTRAINT "ai_prompts_max_tokens_check" CHECK (("max_output_tokens" > 0))
);


ALTER TABLE "public"."ai_prompts" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_prompts" IS 'this table contains the different types of prompts that we want to use to communicate with various AI models';



COMMENT ON COLUMN "public"."ai_prompts"."ai_model" IS 'Shows which model to call on to effectively response to the prompt';



COMMENT ON COLUMN "public"."ai_prompts"."version" IS 'Tracks versioning (if we allow university admins to tweak things)';



COMMENT ON COLUMN "public"."ai_prompts"."max_output_tokens" IS 'Describes the max amount of tokens that should be used for the prompt';



COMMENT ON COLUMN "public"."ai_prompts"."university_id" IS 'Describes which university uses this specialized prompt';



ALTER TABLE "public"."ai_prompts" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."ai_prompts_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."ai_responses" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "response" "text",
    "user_id" "uuid" NOT NULL,
    "user_prompt" "text" DEFAULT 'Not collected'::"text" NOT NULL,
    "output_tokens" bigint DEFAULT '0'::bigint NOT NULL,
    "route_context" "text",
    "escalation_flag" boolean,
    "session_id" "text"
);


ALTER TABLE "public"."ai_responses" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_responses" IS 'Keeps track of all the interactions the API key has with an AI';



COMMENT ON COLUMN "public"."ai_responses"."user_prompt" IS 'This is the prompt sent by the user';



COMMENT ON COLUMN "public"."ai_responses"."output_tokens" IS 'Tracks how many output tokens were needed to produce a response';



COMMENT ON COLUMN "public"."ai_responses"."route_context" IS 'Describes if and where the chatbot sent the user during escalation';



COMMENT ON COLUMN "public"."ai_responses"."escalation_flag" IS 'Simple boolean to track if a user was escalated by AI';



COMMENT ON COLUMN "public"."ai_responses"."session_id" IS 'Dictates ai responses that are related (same user during the same interaction)';



ALTER TABLE "public"."ai_responses" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."ai_responses_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."career_options" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" character varying NOT NULL
);


ALTER TABLE "public"."career_options" OWNER TO "postgres";


ALTER TABLE "public"."career_options" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."career_options_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."class_preferences" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text"
);


ALTER TABLE "public"."class_preferences" OWNER TO "postgres";


COMMENT ON TABLE "public"."class_preferences" IS 'A description of various preference options a student may have when scheduling classes';



ALTER TABLE "public"."class_preferences" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."class_preferences_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."course_offerings" (
    "offering_id" bigint NOT NULL,
    "university_id" bigint DEFAULT 1 NOT NULL,
    "term_name" character varying(50),
    "college" character varying(120),
    "department_code" character varying(16),
    "course_code" character varying(32),
    "section_label" character varying(64),
    "title" character varying(255),
    "description" "text",
    "prerequisites" "text",
    "type" character varying(40),
    "mode" character varying(80),
    "instructor" "text",
    "credits_raw" character varying(16),
    "credits_decimal" numeric(4,1),
    "meetings_json" "jsonb",
    "days_raw" "text",
    "start_time_raw" "text",
    "end_time_raw" "text",
    "location_raw" character varying(200),
    "seats_available" integer,
    "seats_capacity" integer,
    "waitlist_count" integer,
    "source_row_hash" character(64),
    "raw_json" "jsonb",
    "loaded_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."course_offerings" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."course_offerings_offering_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."course_offerings_offering_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."course_offerings_offering_id_seq" OWNED BY "public"."course_offerings"."offering_id";



CREATE TABLE IF NOT EXISTS "public"."grad_plan" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "student_id" bigint,
    "is_active" boolean DEFAULT false NOT NULL,
    "plan_details" json,
    "pending_approval" boolean DEFAULT false NOT NULL,
    "advisor_notes" "text",
    "programs_in_plan" bigint[],
    "pending_edits" boolean DEFAULT false NOT NULL,
    "plan_name" "text" DEFAULT ''::"text",
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."grad_plan" OWNER TO "postgres";


COMMENT ON TABLE "public"."grad_plan" IS 'This is where students'' graduation plans are stored. We track which of their multiple graduation plans is the current one';



COMMENT ON COLUMN "public"."grad_plan"."pending_approval" IS 'When a new grad plan is created, it must be approved by the appropriate advisor to become active';



COMMENT ON COLUMN "public"."grad_plan"."advisor_notes" IS 'A list of edits by term that an advisor suggests before they are willing to approve a grad plan';



COMMENT ON COLUMN "public"."grad_plan"."programs_in_plan" IS 'Each plan needs a list of which programs are being planned for.';



COMMENT ON COLUMN "public"."grad_plan"."pending_edits" IS 'If true, it means an advisor has reviewed the plan and requires edits.';



COMMENT ON COLUMN "public"."grad_plan"."plan_name" IS 'Custom name for the graduation plan, set by the student';



COMMENT ON COLUMN "public"."grad_plan"."updated_at" IS 'Keeps track of the last time a record was modified';



ALTER TABLE "public"."grad_plan" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."grad_plan_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."institution_settings" (
    "university_id" integer NOT NULL,
    "selection_mode" "text" DEFAULT 'MANUAL'::"text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_by" "uuid"
);


ALTER TABLE "public"."institution_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "target_user_id" "uuid" NOT NULL,
    "initiator_user_id" "uuid",
    "type" "text" NOT NULL,
    "context_json" "jsonb",
    "url" "text",
    "is_read" boolean DEFAULT false NOT NULL,
    "read_utc" timestamp with time zone,
    "created_utc" timestamp with time zone DEFAULT "now"() NOT NULL,
    "channel_mask" integer DEFAULT 0 NOT NULL,
    "status" "text" DEFAULT 'queued'::"text" NOT NULL,
    CONSTRAINT "notifications_status_check" CHECK (("status" = ANY (ARRAY['queued'::"text", 'sent'::"text", 'failed'::"text"]))),
    CONSTRAINT "notifications_type_check" CHECK (("char_length"("type") <= 100)),
    CONSTRAINT "notifications_url_check" CHECK (("char_length"("url") <= 512))
);


ALTER TABLE "public"."notifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "fname" character varying DEFAULT 'New'::character varying NOT NULL,
    "lname" character varying DEFAULT 'User'::character varying NOT NULL,
    "university_id" bigint DEFAULT '1'::bigint NOT NULL,
    "role_id" bigint DEFAULT 3 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "onboarded" boolean DEFAULT false NOT NULL,
    "authorization_agreed" boolean DEFAULT false NOT NULL,
    "authorization_agreed_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text"),
    "notif_preferences" "jsonb" DEFAULT '{"events": {"inbox.new": {"push": true, "email": true}}}'::"jsonb",
    "email" "text"
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."profiles" IS 'Essential data about a user';



COMMENT ON COLUMN "public"."profiles"."role_id" IS 'Connects a profile to a role for authorization';



COMMENT ON COLUMN "public"."profiles"."authorization_agreed" IS 'BOOLEAN to check if user has agreed to FERPA policy';



COMMENT ON COLUMN "public"."profiles"."authorization_agreed_at" IS 'Timestamp when user agreed to authorization';



COMMENT ON COLUMN "public"."profiles"."notif_preferences" IS 'Describes the notification preferences a user has, specific to what they do';



CREATE TABLE IF NOT EXISTS "public"."program" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "university_id" bigint DEFAULT '1'::bigint NOT NULL,
    "program_type" "public"."Program Types",
    "version" "text" DEFAULT '1.0'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "modified_at" timestamp without time zone DEFAULT "now"(),
    "requirements" json,
    "is_general_ed" boolean DEFAULT false NOT NULL,
    "course_flow" "jsonb",
    "target_total_credits" real,
    "applicable_start_year" integer,
    "applicable_end_year" integer,
    "applies_to_transfers" boolean DEFAULT true,
    "applies_to_freshmen" boolean DEFAULT true,
    "priority" integer DEFAULT 0,
    "minimum_credits" double precision,
    "program_description" "text"
);


ALTER TABLE "public"."program" OWNER TO "postgres";


COMMENT ON TABLE "public"."program" IS 'Describes attributes of a program including name, type, course requirements, version, date created, date modified';



COMMENT ON COLUMN "public"."program"."is_general_ed" IS 'Allows the db to be queried for general education requirements';



COMMENT ON COLUMN "public"."program"."course_flow" IS 'Data representation of the class flow for a program';



COMMENT ON COLUMN "public"."program"."target_total_credits" IS 'Describes the total credits required for a program';



COMMENT ON COLUMN "public"."program"."minimum_credits" IS 'Describes the smallest sum of credit hours required for a program';



COMMENT ON COLUMN "public"."program"."program_description" IS 'A description of what the program is, what they do, and/or why you''d consider it';



ALTER TABLE "public"."program" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."program_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."roles" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "modified_at" timestamp with time zone DEFAULT "now"(),
    "name" character varying NOT NULL
);


ALTER TABLE "public"."roles" OWNER TO "postgres";


COMMENT ON TABLE "public"."roles" IS 'Description of the various roles available for stu';



ALTER TABLE "public"."roles" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."roles_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."student" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "profile_id" "uuid",
    "selected_programs" bigint[],
    "selected_interests" bigint[],
    "class_preferences" bigint[],
    "year_in_school" "public"."Year In School" DEFAULT 'Freshman'::"public"."Year In School" NOT NULL,
    "est_grad_date" "date",
    "est_grad_term" "text",
    "career_goals" "text",
    "admission_year" integer,
    "is_transfer" "text",
    "gpa" numeric,
    "student_type" "text",
    "work_status" "text",
    CONSTRAINT "student_student_type_check" CHECK (("student_type" = ANY (ARRAY['undergraduate'::"text", 'honor'::"text", 'graduate'::"text"]))),
    CONSTRAINT "student_work_status_check" CHECK ((("work_status" IS NULL) OR ("work_status" = ANY (ARRAY['not_working'::"text", 'part_time'::"text", 'full_time'::"text", 'variable'::"text"]))))
);


ALTER TABLE "public"."student" OWNER TO "postgres";


COMMENT ON TABLE "public"."student" IS 'Essential data related to a user who is a student';



COMMENT ON COLUMN "public"."student"."profile_id" IS 'Connects the student table to the profile table';



COMMENT ON COLUMN "public"."student"."selected_programs" IS 'Record of which programs a student is pursuing';



COMMENT ON COLUMN "public"."student"."selected_interests" IS 'A record of the interests a student selected';



COMMENT ON COLUMN "public"."student"."class_preferences" IS 'A record of which class preferences a student wants to maintain';



COMMENT ON COLUMN "public"."student"."year_in_school" IS 'Describes a student''s overall progress';



COMMENT ON COLUMN "public"."student"."est_grad_term" IS 'Stores the text value to indicate when the student will graduate';



COMMENT ON COLUMN "public"."student"."gpa" IS 'Student GPA from transcript';



COMMENT ON COLUMN "public"."student"."work_status" IS 'Work status during studies: not_working, part_time, full_time, or variable';



ALTER TABLE "public"."student" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."student_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."student_interests" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" character varying DEFAULT ''::character varying NOT NULL
);


ALTER TABLE "public"."student_interests" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_interests" IS 'Contains a growing list of interests students may have';



ALTER TABLE "public"."student_interests" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."student_interests_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."student_schedules" (
    "schedule_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" integer NOT NULL,
    "grad_plan_id" bigint,
    "term_name" "text" NOT NULL,
    "term_index" integer,
    "blocked_times" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "preferences" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_active" boolean DEFAULT false NOT NULL,
    CONSTRAINT "student_schedules_term_name_check" CHECK ((("term_name" IS NOT NULL) AND ("term_name" <> ''::"text")))
);


ALTER TABLE "public"."student_schedules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."university" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "domain" character varying DEFAULT ''::character varying,
    "primary_color" character varying,
    "secondary_color" character varying,
    "accent_color" character varying,
    "dark_color" character varying,
    "light_color" character varying,
    "text_color" character varying,
    "secondary_text_color" character varying,
    "subdomain" "text" DEFAULT ''::"text" NOT NULL,
    "allows_auto_course_choice" boolean DEFAULT true NOT NULL,
    "academic_terms" "jsonb"
);


ALTER TABLE "public"."university" OWNER TO "postgres";


COMMENT ON TABLE "public"."university" IS 'Essential attributes of each partner university';



COMMENT ON COLUMN "public"."university"."primary_color" IS 'School Primary Color';



COMMENT ON COLUMN "public"."university"."text_color" IS 'PRIMARY_Text Color';



COMMENT ON COLUMN "public"."university"."secondary_text_color" IS 'HOVER or secondary text color';



COMMENT ON COLUMN "public"."university"."subdomain" IS 'University Subdomain';



COMMENT ON COLUMN "public"."university"."allows_auto_course_choice" IS 'If true, the university allows students to have their courses chosen by AI in a grad plan';



COMMENT ON COLUMN "public"."university"."academic_terms" IS 'This keeps track of semantic data regarding how an institution organizes their academic year (semesters, semesters + terms, trimester, etc.)';



ALTER TABLE "public"."university" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."university_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."user_courses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "inserted_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "courses" "jsonb",
    "term_metrics" "jsonb",
    "exam_credits" "jsonb",
    "entrance_exams" "jsonb"
);


ALTER TABLE "public"."user_courses" OWNER TO "postgres";


COMMENT ON COLUMN "public"."user_courses"."courses" IS 'A JSON of all of a user''s courses (including term, course code, title, credit value, and grade)';



ALTER TABLE ONLY "public"."course_offerings" ALTER COLUMN "offering_id" SET DEFAULT "nextval"('"public"."course_offerings_offering_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."advisors"
    ADD CONSTRAINT "advisors_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_prompts"
    ADD CONSTRAINT "ai_prompts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_responses"
    ADD CONSTRAINT "ai_responses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."career_options"
    ADD CONSTRAINT "career_options_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."class_preferences"
    ADD CONSTRAINT "class_preferences_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."course_offerings"
    ADD CONSTRAINT "course_offerings_pkey" PRIMARY KEY ("offering_id");



ALTER TABLE ONLY "public"."course_offerings"
    ADD CONSTRAINT "course_offerings_source_row_hash_key" UNIQUE ("source_row_hash");



ALTER TABLE ONLY "public"."grad_plan"
    ADD CONSTRAINT "grad_plan_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."institution_settings"
    ADD CONSTRAINT "institution_settings_pkey" PRIMARY KEY ("university_id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program"
    ADD CONSTRAINT "program_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_interests"
    ADD CONSTRAINT "student_interests_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."student_interests"
    ADD CONSTRAINT "student_interests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student"
    ADD CONSTRAINT "student_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student"
    ADD CONSTRAINT "student_profile_id_key" UNIQUE ("profile_id");



ALTER TABLE ONLY "public"."student_schedules"
    ADD CONSTRAINT "student_schedules_pkey" PRIMARY KEY ("schedule_id");



ALTER TABLE ONLY "public"."student_schedules"
    ADD CONSTRAINT "student_schedules_student_id_grad_plan_id_term_name_key" UNIQUE ("student_id", "grad_plan_id", "term_name");



ALTER TABLE ONLY "public"."university"
    ADD CONSTRAINT "university_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."university"
    ADD CONSTRAINT "university_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."university"
    ADD CONSTRAINT "university_subdomain_key" UNIQUE ("subdomain");



ALTER TABLE ONLY "public"."user_courses"
    ADD CONSTRAINT "user_courses_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_notifications_user_read_created" ON "public"."notifications" USING "btree" ("target_user_id", "is_read", "created_utc" DESC);



CREATE INDEX "idx_user_courses_user_id" ON "public"."user_courses" USING "btree" ("user_id");



CREATE INDEX "profiles_role_idx" ON "public"."profiles" USING "btree" ("role_id");



CREATE INDEX "profiles_university_idx" ON "public"."profiles" USING "btree" ("university_id");



CREATE OR REPLACE TRIGGER "update_student_schedules_updated_at" BEFORE UPDATE ON "public"."student_schedules" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."advisors"
    ADD CONSTRAINT "advisors_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."ai_prompts"
    ADD CONSTRAINT "ai_prompts_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."university"("id");



ALTER TABLE ONLY "public"."ai_responses"
    ADD CONSTRAINT "ai_responses_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."course_offerings"
    ADD CONSTRAINT "fk_course_offerings_university" FOREIGN KEY ("university_id") REFERENCES "public"."university"("id");



ALTER TABLE ONLY "public"."grad_plan"
    ADD CONSTRAINT "grad_plan_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."student"("id");



ALTER TABLE ONLY "public"."institution_settings"
    ADD CONSTRAINT "institution_settings_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."university"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."institution_settings"
    ADD CONSTRAINT "institution_settings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_initiator_user_id_fkey" FOREIGN KEY ("initiator_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."roles"("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."university"("id") ON UPDATE CASCADE ON DELETE SET NULL;



ALTER TABLE ONLY "public"."program"
    ADD CONSTRAINT "program_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."university"("id");



ALTER TABLE ONLY "public"."student"
    ADD CONSTRAINT "student_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_schedules"
    ADD CONSTRAINT "student_schedules_grad_plan_id_fkey" FOREIGN KEY ("grad_plan_id") REFERENCES "public"."grad_plan"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."student_schedules"
    ADD CONSTRAINT "student_schedules_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."student"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_courses"
    ADD CONSTRAINT "user_courses_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Enable insert for authenticated users only" ON "public"."grad_plan" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for users based on user_id" ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Enable read access for all users" ON "public"."ai_prompts" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."grad_plan" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."notifications" FOR SELECT USING (true);



CREATE POLICY "Read own profile" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "id"));



CREATE POLICY "Update own profile" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id"));



CREATE POLICY "Users can delete own courses" ON "public"."user_courses" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own courses" ON "public"."user_courses" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own courses" ON "public"."user_courses" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own courses" ON "public"."user_courses" FOR SELECT USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."advisors" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_prompts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."career_options" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."class_preferences" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."institution_settings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "interests.read" ON "public"."student_interests" FOR SELECT USING (true);



CREATE POLICY "profile: self can read" ON "public"."profiles" FOR SELECT USING (("id" = "auth"."uid"()));



CREATE POLICY "profiles_insert_own" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (("id" = "auth"."uid"()));



CREATE POLICY "profiles_insert_own_student" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK ((("id" = "auth"."uid"()) AND ("role_id" = 3)));



CREATE POLICY "profiles_select_own" ON "public"."profiles" FOR SELECT TO "authenticated" USING (("id" = "auth"."uid"()));



CREATE POLICY "profiles_update_own" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("id" = "auth"."uid"())) WITH CHECK (("id" = "auth"."uid"()));



CREATE POLICY "profiles_update_own_student" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ((("id" = "auth"."uid"()) AND ("role_id" = 3))) WITH CHECK ((("id" = "auth"."uid"()) AND ("role_id" = 3)));



CREATE POLICY "profiles_user_insert" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "profiles_user_select" ON "public"."profiles" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "id"));



CREATE POLICY "profiles_user_update" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "read own profile" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "id"));



CREATE POLICY "read profiles: self or advisor" ON "public"."profiles" FOR SELECT USING ((("id" = "auth"."uid"()) OR "public"."is_advisor"()));



CREATE POLICY "read settings - same institution" ON "public"."institution_settings" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."profiles" "p"
  WHERE (("p"."id" = "auth"."uid"()) AND ("p"."university_id" = "institution_settings"."university_id")))));



CREATE POLICY "student.insert.own" ON "public"."student" FOR INSERT WITH CHECK (("auth"."uid"() = "profile_id"));



CREATE POLICY "student.select.own" ON "public"."student" FOR SELECT USING (("auth"."uid"() = "profile_id"));



CREATE POLICY "student.update.own" ON "public"."student" FOR UPDATE USING (("auth"."uid"() = "profile_id")) WITH CHECK (("auth"."uid"() = "profile_id"));



CREATE POLICY "student_insert_own" ON "public"."student" FOR INSERT TO "authenticated" WITH CHECK (("profile_id" = "auth"."uid"()));



CREATE POLICY "student_select_own" ON "public"."student" FOR SELECT TO "authenticated" USING (("profile_id" = "auth"."uid"()));



CREATE POLICY "student_update_own" ON "public"."student" FOR UPDATE TO "authenticated" USING (("profile_id" = "auth"."uid"())) WITH CHECK (("profile_id" = "auth"."uid"()));



ALTER TABLE "public"."university" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "university.read" ON "public"."university" FOR SELECT USING (true);



CREATE POLICY "upsert own profile" ON "public"."profiles" FOR INSERT WITH CHECK (("id" = "auth"."uid"()));



ALTER TABLE "public"."user_courses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "write settings - admin only" ON "public"."institution_settings" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles" "p"
  WHERE (("p"."id" = "auth"."uid"()) AND ("p"."university_id" = "institution_settings"."university_id") AND ("p"."role_id" = 1))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."profiles" "p"
  WHERE (("p"."id" = "auth"."uid"()) AND ("p"."university_id" = "institution_settings"."university_id") AND ("p"."role_id" = 1)))));



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."grad_plan_broadcast_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_advisor"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_advisor"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_advisor"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notifications_broadcast_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."notifications_broadcast_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notifications_broadcast_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON TABLE "public"."advisors" TO "anon";
GRANT ALL ON TABLE "public"."advisors" TO "authenticated";
GRANT ALL ON TABLE "public"."advisors" TO "service_role";



GRANT ALL ON SEQUENCE "public"."advisors_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."advisors_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."advisors_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."ai_prompts" TO "anon";
GRANT ALL ON TABLE "public"."ai_prompts" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_prompts" TO "service_role";



GRANT ALL ON SEQUENCE "public"."ai_prompts_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."ai_prompts_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."ai_prompts_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."ai_responses" TO "anon";
GRANT ALL ON TABLE "public"."ai_responses" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_responses" TO "service_role";



GRANT ALL ON SEQUENCE "public"."ai_responses_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."ai_responses_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."ai_responses_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."career_options" TO "anon";
GRANT ALL ON TABLE "public"."career_options" TO "authenticated";
GRANT ALL ON TABLE "public"."career_options" TO "service_role";



GRANT ALL ON SEQUENCE "public"."career_options_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."career_options_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."career_options_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."class_preferences" TO "anon";
GRANT ALL ON TABLE "public"."class_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."class_preferences" TO "service_role";



GRANT ALL ON SEQUENCE "public"."class_preferences_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."class_preferences_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."class_preferences_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."course_offerings" TO "anon";
GRANT ALL ON TABLE "public"."course_offerings" TO "authenticated";
GRANT ALL ON TABLE "public"."course_offerings" TO "service_role";



GRANT ALL ON SEQUENCE "public"."course_offerings_offering_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."course_offerings_offering_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."course_offerings_offering_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."grad_plan" TO "anon";
GRANT ALL ON TABLE "public"."grad_plan" TO "authenticated";
GRANT ALL ON TABLE "public"."grad_plan" TO "service_role";



GRANT ALL ON SEQUENCE "public"."grad_plan_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."grad_plan_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."grad_plan_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."institution_settings" TO "anon";
GRANT ALL ON TABLE "public"."institution_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."institution_settings" TO "service_role";



GRANT ALL ON TABLE "public"."notifications" TO "anon";
GRANT ALL ON TABLE "public"."notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."program" TO "anon";
GRANT ALL ON TABLE "public"."program" TO "authenticated";
GRANT ALL ON TABLE "public"."program" TO "service_role";



GRANT ALL ON SEQUENCE "public"."program_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."program_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."program_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."roles" TO "anon";
GRANT ALL ON TABLE "public"."roles" TO "authenticated";
GRANT ALL ON TABLE "public"."roles" TO "service_role";



GRANT ALL ON SEQUENCE "public"."roles_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."roles_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."roles_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."student" TO "anon";
GRANT ALL ON TABLE "public"."student" TO "authenticated";
GRANT ALL ON TABLE "public"."student" TO "service_role";



GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."student_interests" TO "anon";
GRANT ALL ON TABLE "public"."student_interests" TO "authenticated";
GRANT ALL ON TABLE "public"."student_interests" TO "service_role";



GRANT ALL ON SEQUENCE "public"."student_interests_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."student_interests_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."student_interests_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."student_schedules" TO "anon";
GRANT ALL ON TABLE "public"."student_schedules" TO "authenticated";
GRANT ALL ON TABLE "public"."student_schedules" TO "service_role";



GRANT ALL ON TABLE "public"."university" TO "anon";
GRANT ALL ON TABLE "public"."university" TO "authenticated";
GRANT ALL ON TABLE "public"."university" TO "service_role";



GRANT ALL ON SEQUENCE "public"."university_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."university_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."university_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_courses" TO "anon";
GRANT ALL ON TABLE "public"."user_courses" TO "authenticated";
GRANT ALL ON TABLE "public"."user_courses" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






